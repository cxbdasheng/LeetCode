package main

import "fmt"

// 给你一个整数数组 nums 和一个整数 k ，请你返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目。
func main() {
	fmt.Println(numSubarrayProductLessThanK([]int{10, 5, 2, 6}, 100))
}

// 输入：nums = [10,5,2,6], k = 100
// 输出：8
// 解释：8 个乘积小于 100 的子数组分别为：[10]、[5]、[2]、[6]、[10,5]、[5,2]、[2,6]、[5,2,6]。
// 需要注意的是 [10,5,2] 并不是乘积小于 100 的子数组。

// 输入：nums = [1,2,3], k = 0
// 输出：0
func numSubarrayProductLessThanK(nums []int, k int) int {
	n := len(nums)
	l, ans := 0, 0
	mul := 1
	for i := 0; i < n; i++ {
		mul *= nums[i]
		for mul >= k && l <= i {
			mul /= nums[l]
			l++
		}
		// 如何计算 增量 子数组数量是个难点，首先我们看看窗口内的子数组怎么"数"的问题，比如数组[1,2,3,4]，当前窗口[1,2,3]。
		// 我们全量数一次窗口内的子数组:[11,[1,21,[1,2,3],[2],[2,3],[3],一共6个，当right右移后，窗口变成[1,2,3,4]，
		// 这时如果我们再进行"全量数"，上一个窗口[1,2,3]就被重复计算了。
		// 为了消除这种重复，我们需要使用“增量数"，从右向左看，right右移后，窗口新增一个元素，会新增哪些子数组?
		// 例如[1,2,3] ->[1,2,3,4] 窗口内新增个元素4时，新增的子数组肯定要包含4，以4为右端点，
		// 新增的子数组是[41,[3,41,[2,3.41.[1,2.3,4，一共4个，这个增量就是窗口大小 right-left+1。
		ans += i - l + 1
	}
	return ans
}
